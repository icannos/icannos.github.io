<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://icannos.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://icannos.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2023-09-17T20:03:17+00:00</updated><id>https://icannos.github.io//feed.xml</id><title type="html">blank</title><subtitle>Maxime Darrin&apos;s personal webpage, papers, projects, CV and more. </subtitle><entry><title type="html">The maximum dinners problem</title><link href="https://icannos.github.io//blog/2022/the-maximum-dinner-problem/" rel="alternate" type="text/html" title="The maximum dinners problem"/><published>2022-03-19T17:06:00+00:00</published><updated>2022-03-19T17:06:00+00:00</updated><id>https://icannos.github.io//blog/2022/the-maximum-dinner-problem</id><content type="html" xml:base="https://icannos.github.io//blog/2022/the-maximum-dinner-problem/"><![CDATA[<h1 id="context">Context</h1> <p>A couple days ago a friend of mine shared this map of europe and naturally came the question: How many dinners could we attend in one day ? It looked like an easy enough graph problem that is certainly NP-hard, so I decided to dive into the problem.</p> <p><img src="/assets/img/dinners/dinerseurope.jpg" alt="Dinner's time in europe"/></p> <h1 id="problems-statement">Problem’s statement</h1> <p>Let say we have a graph $G = (V, E)$ with $N$ vertices. Each vertice $v \in V$ represents a country and holds a tuple $(T_v^B, T_v^E) \in R_+$ the times at which the dinner begins and ends. The edges of our graph hold the travel time between two places, we denote for $u,v \in V, D(u,v) \in R_+ \cup \set{+\infty}$ the distance/travel time between $u$ and $v$.</p> <p><img src="/assets/img/dinners/graph.png" alt="Graph of the problem" w="300"/></p> <p>The decision problem we are looking at is stated as follow: For $M$ a natural numbler, is there a simple path $ (v_1 \cdots v_K)$ such that:</p> <ul> <li>\(\forall i \in [1, K-1], \, T_{v_i}^E + D(v_i, v_{i+1}) \leq T_{v_{i+1}}^D\) <em>ie.</em> we arrive on time at the next dinner while having left at the end of the last one)</li> <li>K $\geq$ M</li> </ul> <p>If a route does not exist it is encoded by a distance $D(u,v) = +\infty$.</p> <h1 id="np-completeness">NP-completeness</h1> <h2 id="problem-in-np">Problem in NP</h2> <p>It is easy to show that this decision problem is actually in NP. Indeed, for a given path $ (v_1 \cdots v_K) $ and $M$, we can check both conditions in linear time with respect to the size of the solution.</p> <h2 id="np-hardness">NP-hardness</h2> <p>Now the hard part. We want to show that this problem is actually as hard as any other problem in NP. To do so we will build a reduction from the <a href="https://en.wikipedia.org/wiki/Longest_path_problem">Longest Path Problem</a> which is known to be itself NP-complete (hence NP-hard). This problem is about finding the longest simple path in a given graph, you can already see how it can relate to the problem at our hands! The associated decision problem is obviously to decide wether there exists a simple path of lenght greater than $M$.</p> <p>Let say we have an instance $I$ of the Longest Path Problem, we have a graph $G = (V, E)$, with $N$ vertices and $M$. Let’s build $I’$ an instance of the Max-Dinners problem.</p> <ul> <li>We keep the same vertices, so we build $V’ = V$, and for each $v \in V’$ we set $T_v^B = T_v^E = 1$, all the dinners happen instantaneously at the very same time.</li> <li>We keep the same edges so $E’ = E$ and for all $(u,v) \in V’^2$ we set $D(u,v) = 0$ if $(u,v) \in E’$ and $+\infty$ otherwise. If the edge existed in the initial graph we can travel instantaneously through it (so we don’t miss dinner !).</li> <li>And we take M’ = M</li> </ul> <p>Therefore we have $I’ = (G’=(V’, E’), M’)$.</p> <p>This process describes how to build an instance of Max-dinners from a generic instance of Longest path and the built instance has a linear size with respect to the size of the initial problem. Now we have to show that $I$ has a solution if and only if $I’$ has a solution.</p> <p>Let’s assume that we have $(v_1 \cdots v_K)$ a solution of $I$. We then have $K \geq M$ and we can note that it’s a simple path. Moreover, we know that $\forall i, (v_i, v_{i+1}) \in E$, therefore by construction we have $\forall i, D(v_i, v_{i+1}) = 0$ and $T_{v_i}^B = T_{v_i}^E = 1 = T_{v_{i+1}}^B = T_{v_{i+1}}$. It is then easy to check that</p> <ul> <li>$ \forall i \in [1, K-1], \, T_{v_i}^E + D(v_i, v_{i+1}) \leq T_{v_{i+1}}^D $</li> <li>K $\geq M = M’$</li> </ul> <p>We can conclude that $(v_1 \cdots v_K)$ is a solution of $I’$.</p> <p>Conversely, we assume that $(v_1 \cdots v_K)$ is a solution of $I’$. Since $G$ and $G’$ shares vertices and edges, $v_1 \cdots v_K$ is a simple path in $G$ too, of length $K \geq M’ = M$. Therefore it’s a solution of $I$.</p> <p>We can conclude that Max-dinners is at least as hard as Longest path (it’s essentially the same problem as you just saw) and since it’s in NP, it’s NP-complete.</p> <h1 id="solution-for-those-who-came-here-wanting-the-answer-to-the-question">Solution (for those who came here wanting the answer to the question)</h1> <p>In a first version of this article I did not bother to include a solution to the actual problem. After complaints of some friends who don’t give a shit about maths and just want to know which planes to book I wrote down the algorithm and got the solution. <a href="https://github.com/icannos/blog-projects/tree/master/maxdinners">The whole code is available on my github</a>. It turned out that even with the <a href="https://en.wikipedia.org/wiki/Concorde">concorde</a> we can only attend 4 dinners in one day in Europe.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/dinners/animation.gif-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/dinners/animation.gif-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/dinners/animation.gif-1400.webp"/> <img src="/assets/img/dinners/animation.gif" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>First I had to build the data:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>city;dinner_b;dinner_e;lat;lon
Paris,France;19:00;20:00;48.8588897;2.3200410217200766
London,UnitedKingdom;18:30;19:30;51.5073219;-0.1276474
Madrid,Spain;21:30;22:30;40.4167047;-3.7035825
Lisbonne,Portugal;20:00;21:00;38.7077507;-9.1365919
Berlin,Germany;18:00;19:00;52.5186925;13.3996024
Oslo,Norvège;16:00;17:00;59.9133301;10.7389701
Rome,Italy;20:00;21:00;41.8933203;12.4829321
Berne,Switzerland;19:00;20:00;46.9482713;7.4514512
Kiev,Ukraine;19:00;20:00;50.4485578;30.52716228586082
Istanbul,Turkey;19:30;20:30;41.0091982;28.9662187
Stockholm,Sweden;17:00;18:00;59.3251172;18.0710935
Vienna,Austria;18:30;19:30;48.2083537;16.3725042
Warsaw,Poland;19:00;20:00;52.2319581;21.0067249
Athena,Greece;20:00;21:00;37.9839412;23.7283052
Bucarest,Romania;19:30;20:30;44.4361414;26.1027202
Copenhague,Danemark;17:30;18:30;55.6867243;12.5700724
Luxemburg,Luxemburg;18:30;19:30;49.8158683;6.1296751
</code></pre></div></div> <p>And the bruteforce algorithm which comes along:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">datetime</span><span class="p">.</span><span class="nf">timedelta</span><span class="p">(</span>
        <span class="n">hours</span><span class="o">=</span><span class="n">distance</span><span class="p">.</span><span class="nf">distance</span><span class="p">((</span><span class="n">t1</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">t1</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="p">(</span><span class="n">t2</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">t2</span><span class="p">[</span><span class="mi">4</span><span class="p">])).</span><span class="n">km</span> <span class="o">/</span> <span class="n">speed</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">maxdinners</span><span class="p">(</span><span class="n">current_path</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
    <span class="n">bpath</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">left</span><span class="p">:</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">current_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">current_path</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">path</span> <span class="o">=</span> <span class="nf">maxdinners</span><span class="p">(</span><span class="n">current_path</span><span class="p">,</span> <span class="n">left</span> <span class="o">-</span> <span class="p">{</span><span class="n">i</span><span class="p">})</span>
            <span class="n">current_path</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tuples</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">tuples</span><span class="p">[</span><span class="n">current_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nf">d</span><span class="p">(</span>
                <span class="n">tuples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tuples</span><span class="p">[</span><span class="n">current_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="p">):</span>
                <span class="n">current_path</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">path</span> <span class="o">=</span> <span class="nf">maxdinners</span><span class="p">(</span><span class="n">current_path</span><span class="p">,</span> <span class="n">left</span> <span class="o">-</span> <span class="p">{</span><span class="n">i</span><span class="p">})</span>
                <span class="n">current_path</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">bpath</span><span class="p">):</span>
            <span class="n">bpath</span> <span class="o">=</span> <span class="n">path</span>

    <span class="k">return</span> <span class="n">bpath</span> <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">bpath</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">current_path</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">current_path</span><span class="p">]</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="Miscellaneous"/><category term="Complexity Theory"/><category term="NP"/><summary type="html"><![CDATA[Context]]></summary></entry><entry><title type="html">Chess games and studies: pgn2tex</title><link href="https://icannos.github.io//blog/2022/chess-games-and-study-pgn2tex/" rel="alternate" type="text/html" title="Chess games and studies: pgn2tex"/><published>2022-02-18T14:10:00+00:00</published><updated>2022-02-18T14:10:00+00:00</updated><id>https://icannos.github.io//blog/2022/chess-games-and-study-pgn2tex</id><content type="html" xml:base="https://icannos.github.io//blog/2022/chess-games-and-study-pgn2tex/"><![CDATA[<h2 id="back-story">Back story</h2> <p>I began to play chess again because of the lockdowns during covid19 and as many others, I’ve been even more pushed toward the game because of The queen’s gambit. I play on the best chess website ever <a href="https://lichess.org">Lichess</a> which is a libre, free and open-source platform. It’s actually an NGO promoting chess!</p> <p>They released a dataset of chess <a href="https://database.lichess.org">puzzles</a> and host hundreds of <a href="https://lichess.org/study">chess studies</a>. At the same time, I discovered how expensive chess books were and sometimes hard to find. Even though lichess (and others) offers a large variety of ressources to learn and train, they were still online ressources. What if I want to work on paper, with some kind of books ? What’s great with lichess is that everything is under Creative Commons CC0 license, meaning that we can basically do whatever we want with their data. Therefore I decided to write a <a href="https://github.com/icannos/pgn2tex">small python script</a> to convert PGN files to latex source to achieve some kind of notion of chess books and another one to generate puzzles books from the lichess puzzles database.</p> <p>I’m not sure what to do with this so I might as well share it. If some people are interested I suppose it could be possible to build some kind of Open Chess books Collection (The OCBC) based on lichess studies. And maybe one day they could be sold alongside the merch on the lichess website.</p> <h2 id="some-examples">Some examples</h2> <ul> <li>a <a href="https://github.com/icannos/pgn2tex/blob/master/examples/stafford.pdf">book on the Stafford Gambit</a> based on this <a href="https://lichess.org/study/c9YhCd5b">study</a></li> <li>a <a href="https://github.com/icannos/pgn2tex/blob/master/examples/puzzles.pdf">book of puzzles</a> based on the lichess puzzles database.</li> </ul>]]></content><author><name></name></author><category term="scripts"/><category term="miscellaneous"/><category term="chess"/><summary type="html"><![CDATA[Back story]]></summary></entry></feed>